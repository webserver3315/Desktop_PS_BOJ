/*
공유기 설치

각 간격을 기준으로 일일이 확인하는 것이 아닌 이분 탐색의 방식을 이용하는 것이다.

"공유기의 수를 키로 삼을 수 있겠군"

	특정 간격을 기준으로 가능한 위치에 공유기를 설치한다.
	설치한 후에는 다음과 판단한다.
	공유기 수가 더 설치되어야 한다면, 간격을 줄인다.
	공유기 수를 줄여야한다면, 간격을 늘린다.



출처: https://mygumi.tistory.com/301 [마이구미의 HelloWorld]
*/

#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int ld, rd, md;//최저간격, 최대간격, 현재유지중인간격
int N, C;
int RouterNum;

vector<int> housePosition;

void psearch() {
	while (RouterNum != C) {

	}
}

int main() {
	ios::sync_with_stdio(false);
	cin.tie(NULL);

	cin >> N >> C;
	for (int i = 0; i < N; i++) {
		int tmp;
		cin >> tmp;
		housePosition.push_back(tmp);
	}
	sort(housePosition.begin(), housePosition.end());

	/*md를 어떻게 유지할지가 가장 고민이었다. 평균값을 그냥 때려버리면 실제 집간간격이 나오지 않을테니까 아예 처음부터 집간간격으로 되도록 해야하나 싶어서 고민을 길게 했었었다.
	참고한 블로거의 풀이는 전자를 택했다.*/
	ld = 1; rd = housePosition.back() - housePosition.front();/* md = (ld + rd) / C*/;//각각 최저간격, 최대간격, 
	

	int d = 0; int ans = 0;

	while (ld <= rd) {

		int cnt = 1;
		int start = housePosition.front();
		md = (ld + rd) / 2;//굉장히 놀랐다. 왜 C로 안나누고 2로 나누는가??? 설마 차차 심어갈 생각인가? 내 생각은 이 발상을 하지 못한 부분에서 사도로 간 것인가?
		for (int i = 1; i < N; i++) {
			d = housePosition[i] - start;
			if (md <= d) {//거리최소기준인 md보다 d가 더 크거나 같을 때에 한해서 공유기 설치
				cnt++;
				start = housePosition[i];//갓설치된 공유기를 새로운 스타트로
			}
		}//for문이 끝났을 때 cnt가 몇일지, 즉 공유기가 몇 대 설치되었을지는 d에 따라 달려있다.

		if (cnt >= C) {//공유기가 너무 많으면 거리를 넓혀서 줄여야 한다
			if (ans < md)//cnt==C뿐만아니라 좌부등호라도 값대입을 명시하는 이유는, 애초에 과도하게 박았는데도 더 넓은 간격이 나온다면 그거야말로 땡큐니까 답으로 안받을 이유가 없다. 뭐 수학적으로 불가능하지만 경우의 수를 거를 수 있는만큼 코드길이라도 짧게된다.
				ans = md;//도출할 답을 일단 현재유지중인간격 md로 업데이트시키고
			ld = md + 1;//거리최소기준인 md를 조금 더 우측으로 이동시키기위해 ld부터 이동시키자
		}
		else {//너무 적으면 간격을 좁혀서 더 심어야 한다
			//ans = md; // 왜 이건 업데이트 따로 안하지? 아예 가치가 없는 답이라 그런가?
			rd = md - 1;
		}
	}
	cout << ans << endl;

	return 0;
}
/*
파라서치는 밀당할 변수부터 정하라.
이 경우, 공유기의 수를 기준으로 밀당을 하게 된다.
공유기의 수를 구하기 위해 최소거리(md)가 필요하다. 최소거리 이상인 어떠한 거리라도(d) 이격되면 당장 공유기 설치한다. 그런 식으로 그리디하게 공유기수를 쌓는다.
최소거리(md)는 또 공유기의 수에 따라 밀당된다. 즉 이 경우부터 이 문장까지는 순환논리로써 성립된다.

최소이격거리의 최댓값을 구하기 위해 공유기의 수를 구해야 하고
공유기의 수를 구하기 위해 최소거리기준(md)가 필요하고,
최소거리기준(md)을 업데이트하기 위해 파라매트릭용 ld, rd 변수가 필요하다.

최소거리 또한 무식하게 조절하는게 아니라, ld와 rd 값을 이용해 파라매트릭하게 조절된다.
*/


/*
for문은 테스트라고 보면 된다. cnt++를 돌려서, 공유기수가 딱맞거나 과도하면 일단 테스트통과. 아예 적으면 다시돌려야한다.
여느 파라서치처럼 테스트 불통이면 lp rp 값 업데이트시키고 mp값 업데이트시키고 또 테스트돌린다.

아래의 if문은 파라서치 뒤처리라고 보면 된다. cnt값으로 테스트성공여부를 판단하고, 성공했다면 가치판단 후 ans에 반영한다. 그리고 좀 더 최적해를 찾기 위해 ld를 좁힌다.
만일 실패했다면, 가치판단할 가치조차 없이 그냥 rd를 좁히면 된다. 더 촘촘히 박아야하니까.
*/